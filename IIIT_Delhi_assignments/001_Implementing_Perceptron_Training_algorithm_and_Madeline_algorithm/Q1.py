# -*- coding: utf-8 -*-
"""DL A1 Q1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GWKAbSDoksX6cTpUaEiR6wOOe1djPCv-
"""

import numpy as np
import matplotlib.pyplot as plt

x = np.array([[0,0],[0,1],[1,0],[1,1]])
and_out = np.array([-1,-1,-1,1])
or_out = np.array([-1,1,1,1])
xor_out = np.array([-1,1,1,-1])

x_not = np.array([0,1])
not_out = np.array([1,-1])

"""# AND Gate"""

w_1 = 2
w_2 = 1
bias = -3
temp = np.array([0,0,0,0])
count = 0
while (np.sum(temp) != 4):
  for i in range(len(x)):
    val = np.dot(np.array([w_1,w_2]),x[i]) + bias
    if (val*and_out[i] <= 0):
      w_1 = w_1 + and_out[i]*x[i][0]
      w_2 = w_2 + and_out[i]*x[i][1]
      bias = bias + and_out[i]*1
      count += 1
      xx = -bias/w_1
      yy = -bias/w_2
      slope = -yy/xx
      x_values = np.array([0,xx])
      y_values = slope * x_values + yy
      plt.plot(x_values, y_values)
      scatter = plt.scatter(x[:,0],x[:,1],c=and_out)
      plt.legend(handles = scatter.legend_elements()[0],labels = [0,1])
      plt.xlabel("Input 1 (x1)")
      plt.ylabel("Input 2 (x2)")
      plt.title("AND Gate decision boundary after " + str(count) + " epochs for point " + str(x[i]))
      plt.show()
      temp[i] = 0
    else:
      temp[i] = 1
print("Number of steps for convergence in AND Gate: " + str(count))

"""# OR Gate"""

w_1 = 2
w_2 = 1
bias = -3
temp = np.array([0,0,0,0])
count = 0
while (np.sum(temp) != 4):
  for i in range(len(x)):
    val = np.dot(np.array([w_1,w_2]),x[i]) + bias
    if (val*or_out[i] <= 0):
      w_1 = w_1 + or_out[i]*x[i][0]
      w_2 = w_2 + or_out[i]*x[i][1]
      bias = bias + or_out[i]*1
      count += 1
      xx = -bias/w_1
      yy = -bias/w_2
      slope = -yy/xx
      x_values = np.array([0,xx])
      y_values = slope * x_values + yy
      plt.plot(x_values, y_values)
      scatter = plt.scatter(x[:,0],x[:,1],c=or_out)
      plt.legend(handles = scatter.legend_elements()[0],labels = [0,1])
      plt.xlabel("Input 1 (x1)")
      plt.ylabel("Input 2 (x2)")
      plt.title("OR Gate decision boundary after " + str(count) + " epochs for point " + str(x[i]))
      plt.show()
      temp[i] = 0
    else:
      temp[i] = 1
print("Number of steps for convergence in OR Gate: " + str(count))

"""# NOT Gate"""

w_1 = 1.5
bias = 0.5
temp = np.array([0,0])
count = 0
while(np.sum(temp)!=2):
  for i in range(len(x_not)):
    val = w_1 * x_not[i] + bias
    if val * not_out[i] <= 0:
      w_1 = w_1 + not_out[i]*x_not[i]
      bias = bias + not_out[i]
      count += 1
      scatter = plt.scatter(x_not, np.zeros_like(x_not),c=not_out)
      plt.legend(handles = scatter.legend_elements()[0],labels = [0,1])
      plt.plot(-bias/w_1,0,'x')
      plt.vlines(-bias/w_1,ymin=-1, ymax = +1, linestyles='dotted')
      plt.xlabel("Input 1 (x)")
      plt.title("NOT Gate decision boundary after " + str(count) + " epochs.")
      plt.show()
      temp[i]=0
    else:
      temp[i]=1
print("Number of steps for convergence in NOT Gate: " + str(count))

"""# XOR Gate"""

w_1 = 0.5
w_2 = 0.5
bias = 0.5
iter = 0
temp = np.array([0,0,0,0])
count = 0
#error = np.array([])
while (iter != 10):
  count += 1
  iter += 1
  for i in range(len(x)):
    val = np.dot(np.array([w_1,w_2]),x[i]) + bias
    if (val*xor_out[i] <= 0):
      w_1 = w_1 + xor_out[i]*x[i][0]
      w_2 = w_2 + xor_out[i]*x[i][1]
      bias = bias + xor_out[i]
      xx = -bias/w_1
      yy = -bias/w_2
      slope = -yy/xx
      x_values = np.array([0,xx])
      y_values = slope * x_values + yy
      plt.plot(x_values, y_values)
      scatter = plt.scatter(x[:,0],x[:,1],c=xor_out)
      plt.legend(handles = scatter.legend_elements()[0],labels = [0,1])
      plt.xlabel("Input 1 (x1)")
      plt.ylabel("Input 2 (x2)")
      plt.title("XOR Gate decision boundary after " + str(count) + " epochs for point " + str(x[i]))
      plt.show()
      temp[i] = 0
    else:
      temp[i] = 1
#   error = np.append(error,np.sum(temp))
# count_array = [i for i in range(1,count+1)]
# plt.plot(count_array,error)
# plt.xlabel("Epochs")
# plt.ylabel("Error")
# plt.title("Error vs. Epochs for XOR Gate")
# plt.show()

